/* AUTOGENERATED FILE. DO NOT EDIT. */
#include <string.h>
#include <stdlib.h>
#include <setjmp.h>
#include "cmock.h"
#include "Mockapp_nvs.h"

static const char* CMockString_category = "category";
static const char* CMockString_data = "data";
static const char* CMockString_dir = "dir";
static const char* CMockString_getNvsEntriesFromUser = "getNvsEntriesFromUser";
static const char* CMockString_nvsEntriesExist = "nvsEntriesExist";
static const char* CMockString_nvsHandle = "nvsHandle";
static const char* CMockString_openMainNvs = "openMainNvs";
static const char* CMockString_openWorkerNvs = "openWorkerNvs";
static const char* CMockString_refreshSpeedsFromNVS = "refreshSpeedsFromNVS";
static const char* CMockString_removeExtraMainNvsEntries = "removeExtraMainNvsEntries";
static const char* CMockString_removeExtraWorkerNvsEntries = "removeExtraWorkerNvsEntries";
static const char* CMockString_retrieveNvsEntries = "retrieveNvsEntries";
static const char* CMockString_settings = "settings";
static const char* CMockString_storeNvsSettings = "storeNvsSettings";
static const char* CMockString_storeSpeedsToNVS = "storeSpeedsToNVS";
static const char* CMockString_updateNvsSettings = "updateNvsSettings";

typedef struct _CMOCK_openMainNvs_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  nvs_handle_t ReturnVal;

} CMOCK_openMainNvs_CALL_INSTANCE;

typedef struct _CMOCK_openWorkerNvs_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  nvs_handle_t ReturnVal;

} CMOCK_openWorkerNvs_CALL_INSTANCE;

typedef struct _CMOCK_nvsEntriesExist_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  esp_err_t ReturnVal;
  nvs_handle_t Expected_nvsHandle;

} CMOCK_nvsEntriesExist_CALL_INSTANCE;

typedef struct _CMOCK_retrieveNvsEntries_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  esp_err_t ReturnVal;
  nvs_handle_t Expected_nvsHandle;
  UserSettings* Expected_settings;

} CMOCK_retrieveNvsEntries_CALL_INSTANCE;

typedef struct _CMOCK_storeNvsSettings_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  esp_err_t ReturnVal;
  nvs_handle_t Expected_nvsHandle;
  UserSettings Expected_settings;

} CMOCK_storeNvsSettings_CALL_INSTANCE;

typedef struct _CMOCK_removeExtraMainNvsEntries_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  esp_err_t ReturnVal;
  nvs_handle_t Expected_nvsHandle;

} CMOCK_removeExtraMainNvsEntries_CALL_INSTANCE;

typedef struct _CMOCK_removeExtraWorkerNvsEntries_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  esp_err_t ReturnVal;
  nvs_handle_t Expected_nvsHandle;

} CMOCK_removeExtraWorkerNvsEntries_CALL_INSTANCE;

typedef struct _CMOCK_getNvsEntriesFromUser_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  esp_err_t ReturnVal;
  nvs_handle_t Expected_nvsHandle;

} CMOCK_getNvsEntriesFromUser_CALL_INSTANCE;

typedef struct _CMOCK_updateNvsSettings_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  nvs_handle_t Expected_nvsHandle;

} CMOCK_updateNvsSettings_CALL_INSTANCE;

typedef struct _CMOCK_refreshSpeedsFromNVS_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  esp_err_t ReturnVal;
  LEDData* Expected_data;
  Direction Expected_dir;
  SpeedCategory Expected_category;

} CMOCK_refreshSpeedsFromNVS_CALL_INSTANCE;

typedef struct _CMOCK_storeSpeedsToNVS_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  esp_err_t ReturnVal;
  LEDData* Expected_data;
  Direction Expected_dir;
  SpeedCategory Expected_category;

} CMOCK_storeSpeedsToNVS_CALL_INSTANCE;

static struct Mockapp_nvsInstance
{
  char openMainNvs_IgnoreBool;
  nvs_handle_t openMainNvs_FinalReturn;
  CMOCK_MEM_INDEX_TYPE openMainNvs_CallInstance;
  char openWorkerNvs_IgnoreBool;
  nvs_handle_t openWorkerNvs_FinalReturn;
  CMOCK_MEM_INDEX_TYPE openWorkerNvs_CallInstance;
  char nvsEntriesExist_IgnoreBool;
  esp_err_t nvsEntriesExist_FinalReturn;
  CMOCK_MEM_INDEX_TYPE nvsEntriesExist_CallInstance;
  char retrieveNvsEntries_IgnoreBool;
  esp_err_t retrieveNvsEntries_FinalReturn;
  CMOCK_MEM_INDEX_TYPE retrieveNvsEntries_CallInstance;
  char storeNvsSettings_IgnoreBool;
  esp_err_t storeNvsSettings_FinalReturn;
  CMOCK_MEM_INDEX_TYPE storeNvsSettings_CallInstance;
  char removeExtraMainNvsEntries_IgnoreBool;
  esp_err_t removeExtraMainNvsEntries_FinalReturn;
  CMOCK_MEM_INDEX_TYPE removeExtraMainNvsEntries_CallInstance;
  char removeExtraWorkerNvsEntries_IgnoreBool;
  esp_err_t removeExtraWorkerNvsEntries_FinalReturn;
  CMOCK_MEM_INDEX_TYPE removeExtraWorkerNvsEntries_CallInstance;
  char getNvsEntriesFromUser_IgnoreBool;
  esp_err_t getNvsEntriesFromUser_FinalReturn;
  CMOCK_MEM_INDEX_TYPE getNvsEntriesFromUser_CallInstance;
  char updateNvsSettings_IgnoreBool;
  CMOCK_MEM_INDEX_TYPE updateNvsSettings_CallInstance;
  char refreshSpeedsFromNVS_IgnoreBool;
  esp_err_t refreshSpeedsFromNVS_FinalReturn;
  CMOCK_MEM_INDEX_TYPE refreshSpeedsFromNVS_CallInstance;
  char storeSpeedsToNVS_IgnoreBool;
  esp_err_t storeSpeedsToNVS_FinalReturn;
  CMOCK_MEM_INDEX_TYPE storeSpeedsToNVS_CallInstance;
} Mock;


void Mockapp_nvs_Verify(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_MEM_INDEX_TYPE call_instance;
  call_instance = Mock.openMainNvs_CallInstance;
  if (Mock.openMainNvs_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_openMainNvs);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.openWorkerNvs_CallInstance;
  if (Mock.openWorkerNvs_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_openWorkerNvs);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.nvsEntriesExist_CallInstance;
  if (Mock.nvsEntriesExist_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_nvsEntriesExist);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.retrieveNvsEntries_CallInstance;
  if (Mock.retrieveNvsEntries_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_retrieveNvsEntries);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.storeNvsSettings_CallInstance;
  if (Mock.storeNvsSettings_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_storeNvsSettings);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.removeExtraMainNvsEntries_CallInstance;
  if (Mock.removeExtraMainNvsEntries_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_removeExtraMainNvsEntries);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.removeExtraWorkerNvsEntries_CallInstance;
  if (Mock.removeExtraWorkerNvsEntries_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_removeExtraWorkerNvsEntries);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.getNvsEntriesFromUser_CallInstance;
  if (Mock.getNvsEntriesFromUser_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_getNvsEntriesFromUser);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.updateNvsSettings_CallInstance;
  if (Mock.updateNvsSettings_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_updateNvsSettings);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.refreshSpeedsFromNVS_CallInstance;
  if (Mock.refreshSpeedsFromNVS_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_refreshSpeedsFromNVS);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.storeSpeedsToNVS_CallInstance;
  if (Mock.storeSpeedsToNVS_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_storeSpeedsToNVS);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
}

void Mockapp_nvs_Init(void)
{
  Mockapp_nvs_Destroy();
}

void Mockapp_nvs_Destroy(void)
{
  CMock_Guts_MemFreeAll();
  memset(&Mock, 0, sizeof(Mock));
}

nvs_handle_t openMainNvs(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_openMainNvs_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_openMainNvs);
  cmock_call_instance = (CMOCK_openMainNvs_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.openMainNvs_CallInstance);
  Mock.openMainNvs_CallInstance = CMock_Guts_MemNext(Mock.openMainNvs_CallInstance);
  if (Mock.openMainNvs_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.openMainNvs_FinalReturn;
    memcpy((void*)(&Mock.openMainNvs_FinalReturn), (const void*)(&cmock_call_instance->ReturnVal),
         sizeof(nvs_handle_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(nvs_handle_t) ? 1 : -1])); /* add nvs_handle_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void openMainNvs_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, nvs_handle_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_openMainNvs_CALL_INSTANCE));
  CMOCK_openMainNvs_CALL_INSTANCE* cmock_call_instance = (CMOCK_openMainNvs_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.openMainNvs_CallInstance = CMock_Guts_MemChain(Mock.openMainNvs_CallInstance, cmock_guts_index);
  Mock.openMainNvs_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.openMainNvs_IgnoreBool = (char)1;
}

void openMainNvs_CMockStopIgnore(void)
{
  if(Mock.openMainNvs_IgnoreBool)
    Mock.openMainNvs_CallInstance = CMock_Guts_MemNext(Mock.openMainNvs_CallInstance);
  Mock.openMainNvs_IgnoreBool = (char)0;
}

void openMainNvs_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, nvs_handle_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_openMainNvs_CALL_INSTANCE));
  CMOCK_openMainNvs_CALL_INSTANCE* cmock_call_instance = (CMOCK_openMainNvs_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.openMainNvs_CallInstance = CMock_Guts_MemChain(Mock.openMainNvs_CallInstance, cmock_guts_index);
  Mock.openMainNvs_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  memcpy((void*)(&cmock_call_instance->ReturnVal), (const void*)(&cmock_to_return),
         sizeof(nvs_handle_t[sizeof(cmock_to_return) == sizeof(nvs_handle_t) ? 1 : -1])); /* add nvs_handle_t to :treat_as_array if this causes an error */
}

nvs_handle_t openWorkerNvs(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_openWorkerNvs_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_openWorkerNvs);
  cmock_call_instance = (CMOCK_openWorkerNvs_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.openWorkerNvs_CallInstance);
  Mock.openWorkerNvs_CallInstance = CMock_Guts_MemNext(Mock.openWorkerNvs_CallInstance);
  if (Mock.openWorkerNvs_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.openWorkerNvs_FinalReturn;
    memcpy((void*)(&Mock.openWorkerNvs_FinalReturn), (const void*)(&cmock_call_instance->ReturnVal),
         sizeof(nvs_handle_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(nvs_handle_t) ? 1 : -1])); /* add nvs_handle_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void openWorkerNvs_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, nvs_handle_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_openWorkerNvs_CALL_INSTANCE));
  CMOCK_openWorkerNvs_CALL_INSTANCE* cmock_call_instance = (CMOCK_openWorkerNvs_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.openWorkerNvs_CallInstance = CMock_Guts_MemChain(Mock.openWorkerNvs_CallInstance, cmock_guts_index);
  Mock.openWorkerNvs_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.openWorkerNvs_IgnoreBool = (char)1;
}

void openWorkerNvs_CMockStopIgnore(void)
{
  if(Mock.openWorkerNvs_IgnoreBool)
    Mock.openWorkerNvs_CallInstance = CMock_Guts_MemNext(Mock.openWorkerNvs_CallInstance);
  Mock.openWorkerNvs_IgnoreBool = (char)0;
}

void openWorkerNvs_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, nvs_handle_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_openWorkerNvs_CALL_INSTANCE));
  CMOCK_openWorkerNvs_CALL_INSTANCE* cmock_call_instance = (CMOCK_openWorkerNvs_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.openWorkerNvs_CallInstance = CMock_Guts_MemChain(Mock.openWorkerNvs_CallInstance, cmock_guts_index);
  Mock.openWorkerNvs_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  memcpy((void*)(&cmock_call_instance->ReturnVal), (const void*)(&cmock_to_return),
         sizeof(nvs_handle_t[sizeof(cmock_to_return) == sizeof(nvs_handle_t) ? 1 : -1])); /* add nvs_handle_t to :treat_as_array if this causes an error */
}

esp_err_t nvsEntriesExist(nvs_handle_t nvsHandle)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_nvsEntriesExist_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_nvsEntriesExist);
  cmock_call_instance = (CMOCK_nvsEntriesExist_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.nvsEntriesExist_CallInstance);
  Mock.nvsEntriesExist_CallInstance = CMock_Guts_MemNext(Mock.nvsEntriesExist_CallInstance);
  if (Mock.nvsEntriesExist_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.nvsEntriesExist_FinalReturn;
    memcpy((void*)(&Mock.nvsEntriesExist_FinalReturn), (const void*)(&cmock_call_instance->ReturnVal),
         sizeof(esp_err_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(esp_err_t) ? 1 : -1])); /* add esp_err_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_nvsEntriesExist,CMockString_nvsHandle);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_nvsHandle), (void*)(&nvsHandle), sizeof(nvs_handle_t), cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_nvsEntriesExist(CMOCK_nvsEntriesExist_CALL_INSTANCE* cmock_call_instance, nvs_handle_t nvsHandle);
void CMockExpectParameters_nvsEntriesExist(CMOCK_nvsEntriesExist_CALL_INSTANCE* cmock_call_instance, nvs_handle_t nvsHandle)
{
  memcpy((void*)(&cmock_call_instance->Expected_nvsHandle), (const void*)(&nvsHandle),
         sizeof(nvs_handle_t[sizeof(nvsHandle) == sizeof(nvs_handle_t) ? 1 : -1])); /* add nvs_handle_t to :treat_as_array if this causes an error */
}

void nvsEntriesExist_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, esp_err_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_nvsEntriesExist_CALL_INSTANCE));
  CMOCK_nvsEntriesExist_CALL_INSTANCE* cmock_call_instance = (CMOCK_nvsEntriesExist_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.nvsEntriesExist_CallInstance = CMock_Guts_MemChain(Mock.nvsEntriesExist_CallInstance, cmock_guts_index);
  Mock.nvsEntriesExist_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.nvsEntriesExist_IgnoreBool = (char)1;
}

void nvsEntriesExist_CMockStopIgnore(void)
{
  if(Mock.nvsEntriesExist_IgnoreBool)
    Mock.nvsEntriesExist_CallInstance = CMock_Guts_MemNext(Mock.nvsEntriesExist_CallInstance);
  Mock.nvsEntriesExist_IgnoreBool = (char)0;
}

void nvsEntriesExist_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, nvs_handle_t nvsHandle, esp_err_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_nvsEntriesExist_CALL_INSTANCE));
  CMOCK_nvsEntriesExist_CALL_INSTANCE* cmock_call_instance = (CMOCK_nvsEntriesExist_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.nvsEntriesExist_CallInstance = CMock_Guts_MemChain(Mock.nvsEntriesExist_CallInstance, cmock_guts_index);
  Mock.nvsEntriesExist_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_nvsEntriesExist(cmock_call_instance, nvsHandle);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (const void*)(&cmock_to_return),
         sizeof(esp_err_t[sizeof(cmock_to_return) == sizeof(esp_err_t) ? 1 : -1])); /* add esp_err_t to :treat_as_array if this causes an error */
}

esp_err_t retrieveNvsEntries(nvs_handle_t nvsHandle, UserSettings* settings)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_retrieveNvsEntries_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_retrieveNvsEntries);
  cmock_call_instance = (CMOCK_retrieveNvsEntries_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.retrieveNvsEntries_CallInstance);
  Mock.retrieveNvsEntries_CallInstance = CMock_Guts_MemNext(Mock.retrieveNvsEntries_CallInstance);
  if (Mock.retrieveNvsEntries_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.retrieveNvsEntries_FinalReturn;
    memcpy((void*)(&Mock.retrieveNvsEntries_FinalReturn), (const void*)(&cmock_call_instance->ReturnVal),
         sizeof(esp_err_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(esp_err_t) ? 1 : -1])); /* add esp_err_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_retrieveNvsEntries,CMockString_nvsHandle);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_nvsHandle), (void*)(&nvsHandle), sizeof(nvs_handle_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_retrieveNvsEntries,CMockString_settings);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_settings), (void*)(settings), sizeof(UserSettings), cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_retrieveNvsEntries(CMOCK_retrieveNvsEntries_CALL_INSTANCE* cmock_call_instance, nvs_handle_t nvsHandle, UserSettings* settings);
void CMockExpectParameters_retrieveNvsEntries(CMOCK_retrieveNvsEntries_CALL_INSTANCE* cmock_call_instance, nvs_handle_t nvsHandle, UserSettings* settings)
{
  memcpy((void*)(&cmock_call_instance->Expected_nvsHandle), (const void*)(&nvsHandle),
         sizeof(nvs_handle_t[sizeof(nvsHandle) == sizeof(nvs_handle_t) ? 1 : -1])); /* add nvs_handle_t to :treat_as_array if this causes an error */
  cmock_call_instance->Expected_settings = settings;
}

void retrieveNvsEntries_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, esp_err_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_retrieveNvsEntries_CALL_INSTANCE));
  CMOCK_retrieveNvsEntries_CALL_INSTANCE* cmock_call_instance = (CMOCK_retrieveNvsEntries_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.retrieveNvsEntries_CallInstance = CMock_Guts_MemChain(Mock.retrieveNvsEntries_CallInstance, cmock_guts_index);
  Mock.retrieveNvsEntries_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.retrieveNvsEntries_IgnoreBool = (char)1;
}

void retrieveNvsEntries_CMockStopIgnore(void)
{
  if(Mock.retrieveNvsEntries_IgnoreBool)
    Mock.retrieveNvsEntries_CallInstance = CMock_Guts_MemNext(Mock.retrieveNvsEntries_CallInstance);
  Mock.retrieveNvsEntries_IgnoreBool = (char)0;
}

void retrieveNvsEntries_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, nvs_handle_t nvsHandle, UserSettings* settings, esp_err_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_retrieveNvsEntries_CALL_INSTANCE));
  CMOCK_retrieveNvsEntries_CALL_INSTANCE* cmock_call_instance = (CMOCK_retrieveNvsEntries_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.retrieveNvsEntries_CallInstance = CMock_Guts_MemChain(Mock.retrieveNvsEntries_CallInstance, cmock_guts_index);
  Mock.retrieveNvsEntries_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_retrieveNvsEntries(cmock_call_instance, nvsHandle, settings);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (const void*)(&cmock_to_return),
         sizeof(esp_err_t[sizeof(cmock_to_return) == sizeof(esp_err_t) ? 1 : -1])); /* add esp_err_t to :treat_as_array if this causes an error */
}

esp_err_t storeNvsSettings(nvs_handle_t nvsHandle, UserSettings settings)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_storeNvsSettings_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_storeNvsSettings);
  cmock_call_instance = (CMOCK_storeNvsSettings_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.storeNvsSettings_CallInstance);
  Mock.storeNvsSettings_CallInstance = CMock_Guts_MemNext(Mock.storeNvsSettings_CallInstance);
  if (Mock.storeNvsSettings_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.storeNvsSettings_FinalReturn;
    memcpy((void*)(&Mock.storeNvsSettings_FinalReturn), (const void*)(&cmock_call_instance->ReturnVal),
         sizeof(esp_err_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(esp_err_t) ? 1 : -1])); /* add esp_err_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_storeNvsSettings,CMockString_nvsHandle);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_nvsHandle), (void*)(&nvsHandle), sizeof(nvs_handle_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_storeNvsSettings,CMockString_settings);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_settings), (void*)(&settings), sizeof(UserSettings), cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_storeNvsSettings(CMOCK_storeNvsSettings_CALL_INSTANCE* cmock_call_instance, nvs_handle_t nvsHandle, UserSettings settings);
void CMockExpectParameters_storeNvsSettings(CMOCK_storeNvsSettings_CALL_INSTANCE* cmock_call_instance, nvs_handle_t nvsHandle, UserSettings settings)
{
  memcpy((void*)(&cmock_call_instance->Expected_nvsHandle), (const void*)(&nvsHandle),
         sizeof(nvs_handle_t[sizeof(nvsHandle) == sizeof(nvs_handle_t) ? 1 : -1])); /* add nvs_handle_t to :treat_as_array if this causes an error */
  memcpy((void*)(&cmock_call_instance->Expected_settings), (const void*)(&settings),
         sizeof(UserSettings[sizeof(settings) == sizeof(UserSettings) ? 1 : -1])); /* add UserSettings to :treat_as_array if this causes an error */
}

void storeNvsSettings_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, esp_err_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_storeNvsSettings_CALL_INSTANCE));
  CMOCK_storeNvsSettings_CALL_INSTANCE* cmock_call_instance = (CMOCK_storeNvsSettings_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.storeNvsSettings_CallInstance = CMock_Guts_MemChain(Mock.storeNvsSettings_CallInstance, cmock_guts_index);
  Mock.storeNvsSettings_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.storeNvsSettings_IgnoreBool = (char)1;
}

void storeNvsSettings_CMockStopIgnore(void)
{
  if(Mock.storeNvsSettings_IgnoreBool)
    Mock.storeNvsSettings_CallInstance = CMock_Guts_MemNext(Mock.storeNvsSettings_CallInstance);
  Mock.storeNvsSettings_IgnoreBool = (char)0;
}

void storeNvsSettings_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, nvs_handle_t nvsHandle, UserSettings settings, esp_err_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_storeNvsSettings_CALL_INSTANCE));
  CMOCK_storeNvsSettings_CALL_INSTANCE* cmock_call_instance = (CMOCK_storeNvsSettings_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.storeNvsSettings_CallInstance = CMock_Guts_MemChain(Mock.storeNvsSettings_CallInstance, cmock_guts_index);
  Mock.storeNvsSettings_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_storeNvsSettings(cmock_call_instance, nvsHandle, settings);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (const void*)(&cmock_to_return),
         sizeof(esp_err_t[sizeof(cmock_to_return) == sizeof(esp_err_t) ? 1 : -1])); /* add esp_err_t to :treat_as_array if this causes an error */
}

esp_err_t removeExtraMainNvsEntries(nvs_handle_t nvsHandle)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_removeExtraMainNvsEntries_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_removeExtraMainNvsEntries);
  cmock_call_instance = (CMOCK_removeExtraMainNvsEntries_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.removeExtraMainNvsEntries_CallInstance);
  Mock.removeExtraMainNvsEntries_CallInstance = CMock_Guts_MemNext(Mock.removeExtraMainNvsEntries_CallInstance);
  if (Mock.removeExtraMainNvsEntries_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.removeExtraMainNvsEntries_FinalReturn;
    memcpy((void*)(&Mock.removeExtraMainNvsEntries_FinalReturn), (const void*)(&cmock_call_instance->ReturnVal),
         sizeof(esp_err_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(esp_err_t) ? 1 : -1])); /* add esp_err_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_removeExtraMainNvsEntries,CMockString_nvsHandle);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_nvsHandle), (void*)(&nvsHandle), sizeof(nvs_handle_t), cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_removeExtraMainNvsEntries(CMOCK_removeExtraMainNvsEntries_CALL_INSTANCE* cmock_call_instance, nvs_handle_t nvsHandle);
void CMockExpectParameters_removeExtraMainNvsEntries(CMOCK_removeExtraMainNvsEntries_CALL_INSTANCE* cmock_call_instance, nvs_handle_t nvsHandle)
{
  memcpy((void*)(&cmock_call_instance->Expected_nvsHandle), (const void*)(&nvsHandle),
         sizeof(nvs_handle_t[sizeof(nvsHandle) == sizeof(nvs_handle_t) ? 1 : -1])); /* add nvs_handle_t to :treat_as_array if this causes an error */
}

void removeExtraMainNvsEntries_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, esp_err_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_removeExtraMainNvsEntries_CALL_INSTANCE));
  CMOCK_removeExtraMainNvsEntries_CALL_INSTANCE* cmock_call_instance = (CMOCK_removeExtraMainNvsEntries_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.removeExtraMainNvsEntries_CallInstance = CMock_Guts_MemChain(Mock.removeExtraMainNvsEntries_CallInstance, cmock_guts_index);
  Mock.removeExtraMainNvsEntries_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.removeExtraMainNvsEntries_IgnoreBool = (char)1;
}

void removeExtraMainNvsEntries_CMockStopIgnore(void)
{
  if(Mock.removeExtraMainNvsEntries_IgnoreBool)
    Mock.removeExtraMainNvsEntries_CallInstance = CMock_Guts_MemNext(Mock.removeExtraMainNvsEntries_CallInstance);
  Mock.removeExtraMainNvsEntries_IgnoreBool = (char)0;
}

void removeExtraMainNvsEntries_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, nvs_handle_t nvsHandle, esp_err_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_removeExtraMainNvsEntries_CALL_INSTANCE));
  CMOCK_removeExtraMainNvsEntries_CALL_INSTANCE* cmock_call_instance = (CMOCK_removeExtraMainNvsEntries_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.removeExtraMainNvsEntries_CallInstance = CMock_Guts_MemChain(Mock.removeExtraMainNvsEntries_CallInstance, cmock_guts_index);
  Mock.removeExtraMainNvsEntries_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_removeExtraMainNvsEntries(cmock_call_instance, nvsHandle);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (const void*)(&cmock_to_return),
         sizeof(esp_err_t[sizeof(cmock_to_return) == sizeof(esp_err_t) ? 1 : -1])); /* add esp_err_t to :treat_as_array if this causes an error */
}

esp_err_t removeExtraWorkerNvsEntries(nvs_handle_t nvsHandle)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_removeExtraWorkerNvsEntries_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_removeExtraWorkerNvsEntries);
  cmock_call_instance = (CMOCK_removeExtraWorkerNvsEntries_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.removeExtraWorkerNvsEntries_CallInstance);
  Mock.removeExtraWorkerNvsEntries_CallInstance = CMock_Guts_MemNext(Mock.removeExtraWorkerNvsEntries_CallInstance);
  if (Mock.removeExtraWorkerNvsEntries_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.removeExtraWorkerNvsEntries_FinalReturn;
    memcpy((void*)(&Mock.removeExtraWorkerNvsEntries_FinalReturn), (const void*)(&cmock_call_instance->ReturnVal),
         sizeof(esp_err_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(esp_err_t) ? 1 : -1])); /* add esp_err_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_removeExtraWorkerNvsEntries,CMockString_nvsHandle);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_nvsHandle), (void*)(&nvsHandle), sizeof(nvs_handle_t), cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_removeExtraWorkerNvsEntries(CMOCK_removeExtraWorkerNvsEntries_CALL_INSTANCE* cmock_call_instance, nvs_handle_t nvsHandle);
void CMockExpectParameters_removeExtraWorkerNvsEntries(CMOCK_removeExtraWorkerNvsEntries_CALL_INSTANCE* cmock_call_instance, nvs_handle_t nvsHandle)
{
  memcpy((void*)(&cmock_call_instance->Expected_nvsHandle), (const void*)(&nvsHandle),
         sizeof(nvs_handle_t[sizeof(nvsHandle) == sizeof(nvs_handle_t) ? 1 : -1])); /* add nvs_handle_t to :treat_as_array if this causes an error */
}

void removeExtraWorkerNvsEntries_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, esp_err_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_removeExtraWorkerNvsEntries_CALL_INSTANCE));
  CMOCK_removeExtraWorkerNvsEntries_CALL_INSTANCE* cmock_call_instance = (CMOCK_removeExtraWorkerNvsEntries_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.removeExtraWorkerNvsEntries_CallInstance = CMock_Guts_MemChain(Mock.removeExtraWorkerNvsEntries_CallInstance, cmock_guts_index);
  Mock.removeExtraWorkerNvsEntries_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.removeExtraWorkerNvsEntries_IgnoreBool = (char)1;
}

void removeExtraWorkerNvsEntries_CMockStopIgnore(void)
{
  if(Mock.removeExtraWorkerNvsEntries_IgnoreBool)
    Mock.removeExtraWorkerNvsEntries_CallInstance = CMock_Guts_MemNext(Mock.removeExtraWorkerNvsEntries_CallInstance);
  Mock.removeExtraWorkerNvsEntries_IgnoreBool = (char)0;
}

void removeExtraWorkerNvsEntries_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, nvs_handle_t nvsHandle, esp_err_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_removeExtraWorkerNvsEntries_CALL_INSTANCE));
  CMOCK_removeExtraWorkerNvsEntries_CALL_INSTANCE* cmock_call_instance = (CMOCK_removeExtraWorkerNvsEntries_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.removeExtraWorkerNvsEntries_CallInstance = CMock_Guts_MemChain(Mock.removeExtraWorkerNvsEntries_CallInstance, cmock_guts_index);
  Mock.removeExtraWorkerNvsEntries_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_removeExtraWorkerNvsEntries(cmock_call_instance, nvsHandle);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (const void*)(&cmock_to_return),
         sizeof(esp_err_t[sizeof(cmock_to_return) == sizeof(esp_err_t) ? 1 : -1])); /* add esp_err_t to :treat_as_array if this causes an error */
}

esp_err_t getNvsEntriesFromUser(nvs_handle_t nvsHandle)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_getNvsEntriesFromUser_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_getNvsEntriesFromUser);
  cmock_call_instance = (CMOCK_getNvsEntriesFromUser_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.getNvsEntriesFromUser_CallInstance);
  Mock.getNvsEntriesFromUser_CallInstance = CMock_Guts_MemNext(Mock.getNvsEntriesFromUser_CallInstance);
  if (Mock.getNvsEntriesFromUser_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.getNvsEntriesFromUser_FinalReturn;
    memcpy((void*)(&Mock.getNvsEntriesFromUser_FinalReturn), (const void*)(&cmock_call_instance->ReturnVal),
         sizeof(esp_err_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(esp_err_t) ? 1 : -1])); /* add esp_err_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_getNvsEntriesFromUser,CMockString_nvsHandle);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_nvsHandle), (void*)(&nvsHandle), sizeof(nvs_handle_t), cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_getNvsEntriesFromUser(CMOCK_getNvsEntriesFromUser_CALL_INSTANCE* cmock_call_instance, nvs_handle_t nvsHandle);
void CMockExpectParameters_getNvsEntriesFromUser(CMOCK_getNvsEntriesFromUser_CALL_INSTANCE* cmock_call_instance, nvs_handle_t nvsHandle)
{
  memcpy((void*)(&cmock_call_instance->Expected_nvsHandle), (const void*)(&nvsHandle),
         sizeof(nvs_handle_t[sizeof(nvsHandle) == sizeof(nvs_handle_t) ? 1 : -1])); /* add nvs_handle_t to :treat_as_array if this causes an error */
}

void getNvsEntriesFromUser_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, esp_err_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_getNvsEntriesFromUser_CALL_INSTANCE));
  CMOCK_getNvsEntriesFromUser_CALL_INSTANCE* cmock_call_instance = (CMOCK_getNvsEntriesFromUser_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.getNvsEntriesFromUser_CallInstance = CMock_Guts_MemChain(Mock.getNvsEntriesFromUser_CallInstance, cmock_guts_index);
  Mock.getNvsEntriesFromUser_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.getNvsEntriesFromUser_IgnoreBool = (char)1;
}

void getNvsEntriesFromUser_CMockStopIgnore(void)
{
  if(Mock.getNvsEntriesFromUser_IgnoreBool)
    Mock.getNvsEntriesFromUser_CallInstance = CMock_Guts_MemNext(Mock.getNvsEntriesFromUser_CallInstance);
  Mock.getNvsEntriesFromUser_IgnoreBool = (char)0;
}

void getNvsEntriesFromUser_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, nvs_handle_t nvsHandle, esp_err_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_getNvsEntriesFromUser_CALL_INSTANCE));
  CMOCK_getNvsEntriesFromUser_CALL_INSTANCE* cmock_call_instance = (CMOCK_getNvsEntriesFromUser_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.getNvsEntriesFromUser_CallInstance = CMock_Guts_MemChain(Mock.getNvsEntriesFromUser_CallInstance, cmock_guts_index);
  Mock.getNvsEntriesFromUser_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_getNvsEntriesFromUser(cmock_call_instance, nvsHandle);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (const void*)(&cmock_to_return),
         sizeof(esp_err_t[sizeof(cmock_to_return) == sizeof(esp_err_t) ? 1 : -1])); /* add esp_err_t to :treat_as_array if this causes an error */
}

void updateNvsSettings(nvs_handle_t nvsHandle)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_updateNvsSettings_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_updateNvsSettings);
  cmock_call_instance = (CMOCK_updateNvsSettings_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.updateNvsSettings_CallInstance);
  Mock.updateNvsSettings_CallInstance = CMock_Guts_MemNext(Mock.updateNvsSettings_CallInstance);
  if (Mock.updateNvsSettings_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    return;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_updateNvsSettings,CMockString_nvsHandle);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_nvsHandle), (void*)(&nvsHandle), sizeof(nvs_handle_t), cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
}

void CMockExpectParameters_updateNvsSettings(CMOCK_updateNvsSettings_CALL_INSTANCE* cmock_call_instance, nvs_handle_t nvsHandle);
void CMockExpectParameters_updateNvsSettings(CMOCK_updateNvsSettings_CALL_INSTANCE* cmock_call_instance, nvs_handle_t nvsHandle)
{
  memcpy((void*)(&cmock_call_instance->Expected_nvsHandle), (const void*)(&nvsHandle),
         sizeof(nvs_handle_t[sizeof(nvsHandle) == sizeof(nvs_handle_t) ? 1 : -1])); /* add nvs_handle_t to :treat_as_array if this causes an error */
}

void updateNvsSettings_CMockIgnore(void)
{
  Mock.updateNvsSettings_IgnoreBool = (char)1;
}

void updateNvsSettings_CMockStopIgnore(void)
{
  Mock.updateNvsSettings_IgnoreBool = (char)0;
}

void updateNvsSettings_CMockExpect(UNITY_LINE_TYPE cmock_line, nvs_handle_t nvsHandle)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_updateNvsSettings_CALL_INSTANCE));
  CMOCK_updateNvsSettings_CALL_INSTANCE* cmock_call_instance = (CMOCK_updateNvsSettings_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.updateNvsSettings_CallInstance = CMock_Guts_MemChain(Mock.updateNvsSettings_CallInstance, cmock_guts_index);
  Mock.updateNvsSettings_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_updateNvsSettings(cmock_call_instance, nvsHandle);
}

esp_err_t refreshSpeedsFromNVS(LEDData* data, Direction dir, SpeedCategory category)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_refreshSpeedsFromNVS_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_refreshSpeedsFromNVS);
  cmock_call_instance = (CMOCK_refreshSpeedsFromNVS_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.refreshSpeedsFromNVS_CallInstance);
  Mock.refreshSpeedsFromNVS_CallInstance = CMock_Guts_MemNext(Mock.refreshSpeedsFromNVS_CallInstance);
  if (Mock.refreshSpeedsFromNVS_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.refreshSpeedsFromNVS_FinalReturn;
    memcpy((void*)(&Mock.refreshSpeedsFromNVS_FinalReturn), (const void*)(&cmock_call_instance->ReturnVal),
         sizeof(esp_err_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(esp_err_t) ? 1 : -1])); /* add esp_err_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_refreshSpeedsFromNVS,CMockString_data);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_data), (void*)(data), sizeof(LEDData), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_refreshSpeedsFromNVS,CMockString_dir);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_dir), (void*)(&dir), sizeof(Direction), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_refreshSpeedsFromNVS,CMockString_category);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_category), (void*)(&category), sizeof(SpeedCategory), cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_refreshSpeedsFromNVS(CMOCK_refreshSpeedsFromNVS_CALL_INSTANCE* cmock_call_instance, LEDData* data, Direction dir, SpeedCategory category);
void CMockExpectParameters_refreshSpeedsFromNVS(CMOCK_refreshSpeedsFromNVS_CALL_INSTANCE* cmock_call_instance, LEDData* data, Direction dir, SpeedCategory category)
{
  cmock_call_instance->Expected_data = data;
  memcpy((void*)(&cmock_call_instance->Expected_dir), (const void*)(&dir),
         sizeof(Direction[sizeof(dir) == sizeof(Direction) ? 1 : -1])); /* add Direction to :treat_as_array if this causes an error */
  memcpy((void*)(&cmock_call_instance->Expected_category), (const void*)(&category),
         sizeof(SpeedCategory[sizeof(category) == sizeof(SpeedCategory) ? 1 : -1])); /* add SpeedCategory to :treat_as_array if this causes an error */
}

void refreshSpeedsFromNVS_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, esp_err_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_refreshSpeedsFromNVS_CALL_INSTANCE));
  CMOCK_refreshSpeedsFromNVS_CALL_INSTANCE* cmock_call_instance = (CMOCK_refreshSpeedsFromNVS_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.refreshSpeedsFromNVS_CallInstance = CMock_Guts_MemChain(Mock.refreshSpeedsFromNVS_CallInstance, cmock_guts_index);
  Mock.refreshSpeedsFromNVS_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.refreshSpeedsFromNVS_IgnoreBool = (char)1;
}

void refreshSpeedsFromNVS_CMockStopIgnore(void)
{
  if(Mock.refreshSpeedsFromNVS_IgnoreBool)
    Mock.refreshSpeedsFromNVS_CallInstance = CMock_Guts_MemNext(Mock.refreshSpeedsFromNVS_CallInstance);
  Mock.refreshSpeedsFromNVS_IgnoreBool = (char)0;
}

void refreshSpeedsFromNVS_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, LEDData* data, Direction dir, SpeedCategory category, esp_err_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_refreshSpeedsFromNVS_CALL_INSTANCE));
  CMOCK_refreshSpeedsFromNVS_CALL_INSTANCE* cmock_call_instance = (CMOCK_refreshSpeedsFromNVS_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.refreshSpeedsFromNVS_CallInstance = CMock_Guts_MemChain(Mock.refreshSpeedsFromNVS_CallInstance, cmock_guts_index);
  Mock.refreshSpeedsFromNVS_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_refreshSpeedsFromNVS(cmock_call_instance, data, dir, category);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (const void*)(&cmock_to_return),
         sizeof(esp_err_t[sizeof(cmock_to_return) == sizeof(esp_err_t) ? 1 : -1])); /* add esp_err_t to :treat_as_array if this causes an error */
}

esp_err_t storeSpeedsToNVS(LEDData* data, Direction dir, SpeedCategory category)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_storeSpeedsToNVS_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_storeSpeedsToNVS);
  cmock_call_instance = (CMOCK_storeSpeedsToNVS_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.storeSpeedsToNVS_CallInstance);
  Mock.storeSpeedsToNVS_CallInstance = CMock_Guts_MemNext(Mock.storeSpeedsToNVS_CallInstance);
  if (Mock.storeSpeedsToNVS_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.storeSpeedsToNVS_FinalReturn;
    memcpy((void*)(&Mock.storeSpeedsToNVS_FinalReturn), (const void*)(&cmock_call_instance->ReturnVal),
         sizeof(esp_err_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(esp_err_t) ? 1 : -1])); /* add esp_err_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_storeSpeedsToNVS,CMockString_data);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_data), (void*)(data), sizeof(LEDData), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_storeSpeedsToNVS,CMockString_dir);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_dir), (void*)(&dir), sizeof(Direction), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_storeSpeedsToNVS,CMockString_category);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_category), (void*)(&category), sizeof(SpeedCategory), cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_storeSpeedsToNVS(CMOCK_storeSpeedsToNVS_CALL_INSTANCE* cmock_call_instance, LEDData* data, Direction dir, SpeedCategory category);
void CMockExpectParameters_storeSpeedsToNVS(CMOCK_storeSpeedsToNVS_CALL_INSTANCE* cmock_call_instance, LEDData* data, Direction dir, SpeedCategory category)
{
  cmock_call_instance->Expected_data = data;
  memcpy((void*)(&cmock_call_instance->Expected_dir), (const void*)(&dir),
         sizeof(Direction[sizeof(dir) == sizeof(Direction) ? 1 : -1])); /* add Direction to :treat_as_array if this causes an error */
  memcpy((void*)(&cmock_call_instance->Expected_category), (const void*)(&category),
         sizeof(SpeedCategory[sizeof(category) == sizeof(SpeedCategory) ? 1 : -1])); /* add SpeedCategory to :treat_as_array if this causes an error */
}

void storeSpeedsToNVS_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, esp_err_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_storeSpeedsToNVS_CALL_INSTANCE));
  CMOCK_storeSpeedsToNVS_CALL_INSTANCE* cmock_call_instance = (CMOCK_storeSpeedsToNVS_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.storeSpeedsToNVS_CallInstance = CMock_Guts_MemChain(Mock.storeSpeedsToNVS_CallInstance, cmock_guts_index);
  Mock.storeSpeedsToNVS_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.storeSpeedsToNVS_IgnoreBool = (char)1;
}

void storeSpeedsToNVS_CMockStopIgnore(void)
{
  if(Mock.storeSpeedsToNVS_IgnoreBool)
    Mock.storeSpeedsToNVS_CallInstance = CMock_Guts_MemNext(Mock.storeSpeedsToNVS_CallInstance);
  Mock.storeSpeedsToNVS_IgnoreBool = (char)0;
}

void storeSpeedsToNVS_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, LEDData* data, Direction dir, SpeedCategory category, esp_err_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_storeSpeedsToNVS_CALL_INSTANCE));
  CMOCK_storeSpeedsToNVS_CALL_INSTANCE* cmock_call_instance = (CMOCK_storeSpeedsToNVS_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.storeSpeedsToNVS_CallInstance = CMock_Guts_MemChain(Mock.storeSpeedsToNVS_CallInstance, cmock_guts_index);
  Mock.storeSpeedsToNVS_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_storeSpeedsToNVS(cmock_call_instance, data, dir, category);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (const void*)(&cmock_to_return),
         sizeof(esp_err_t[sizeof(cmock_to_return) == sizeof(esp_err_t) ? 1 : -1])); /* add esp_err_t to :treat_as_array if this causes an error */
}

