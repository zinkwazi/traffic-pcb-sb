/* AUTOGENERATED FILE. DO NOT EDIT. */
#include <string.h>
#include <stdlib.h>
#include <setjmp.h>
#include "cmock.h"
#include "Mockindicators.h"

static const char* CMockString_delay = "delay";
static const char* CMockString_dir = "dir";
static const char* CMockString_indicateDirection = "indicateDirection";
static const char* CMockString_indicateNorthbound = "indicateNorthbound";
static const char* CMockString_indicateOTAAvailable = "indicateOTAAvailable";
static const char* CMockString_indicateOTAFailure = "indicateOTAFailure";
static const char* CMockString_indicateOTASuccess = "indicateOTASuccess";
static const char* CMockString_indicateOTAUpdate = "indicateOTAUpdate";
static const char* CMockString_indicateSouthbound = "indicateSouthbound";
static const char* CMockString_indicateWifiConnected = "indicateWifiConnected";
static const char* CMockString_indicateWifiNotConnected = "indicateWifiNotConnected";

typedef struct _CMOCK_indicateWifiConnected_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  esp_err_t ReturnVal;

} CMOCK_indicateWifiConnected_CALL_INSTANCE;

typedef struct _CMOCK_indicateWifiNotConnected_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  esp_err_t ReturnVal;

} CMOCK_indicateWifiNotConnected_CALL_INSTANCE;

typedef struct _CMOCK_indicateOTAAvailable_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  esp_err_t ReturnVal;

} CMOCK_indicateOTAAvailable_CALL_INSTANCE;

typedef struct _CMOCK_indicateOTAUpdate_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  esp_err_t ReturnVal;

} CMOCK_indicateOTAUpdate_CALL_INSTANCE;

typedef struct _CMOCK_indicateOTAFailure_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  esp_err_t ReturnVal;
  int32_t Expected_delay;

} CMOCK_indicateOTAFailure_CALL_INSTANCE;

typedef struct _CMOCK_indicateOTASuccess_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  esp_err_t ReturnVal;
  int32_t Expected_delay;

} CMOCK_indicateOTASuccess_CALL_INSTANCE;

typedef struct _CMOCK_indicateNorthbound_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  esp_err_t ReturnVal;

} CMOCK_indicateNorthbound_CALL_INSTANCE;

typedef struct _CMOCK_indicateSouthbound_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  esp_err_t ReturnVal;

} CMOCK_indicateSouthbound_CALL_INSTANCE;

typedef struct _CMOCK_indicateDirection_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  esp_err_t ReturnVal;
  Direction Expected_dir;

} CMOCK_indicateDirection_CALL_INSTANCE;

static struct MockindicatorsInstance
{
  char indicateWifiConnected_IgnoreBool;
  esp_err_t indicateWifiConnected_FinalReturn;
  CMOCK_MEM_INDEX_TYPE indicateWifiConnected_CallInstance;
  char indicateWifiNotConnected_IgnoreBool;
  esp_err_t indicateWifiNotConnected_FinalReturn;
  CMOCK_MEM_INDEX_TYPE indicateWifiNotConnected_CallInstance;
  char indicateOTAAvailable_IgnoreBool;
  esp_err_t indicateOTAAvailable_FinalReturn;
  CMOCK_MEM_INDEX_TYPE indicateOTAAvailable_CallInstance;
  char indicateOTAUpdate_IgnoreBool;
  esp_err_t indicateOTAUpdate_FinalReturn;
  CMOCK_MEM_INDEX_TYPE indicateOTAUpdate_CallInstance;
  char indicateOTAFailure_IgnoreBool;
  esp_err_t indicateOTAFailure_FinalReturn;
  CMOCK_MEM_INDEX_TYPE indicateOTAFailure_CallInstance;
  char indicateOTASuccess_IgnoreBool;
  esp_err_t indicateOTASuccess_FinalReturn;
  CMOCK_MEM_INDEX_TYPE indicateOTASuccess_CallInstance;
  char indicateNorthbound_IgnoreBool;
  esp_err_t indicateNorthbound_FinalReturn;
  CMOCK_MEM_INDEX_TYPE indicateNorthbound_CallInstance;
  char indicateSouthbound_IgnoreBool;
  esp_err_t indicateSouthbound_FinalReturn;
  CMOCK_MEM_INDEX_TYPE indicateSouthbound_CallInstance;
  char indicateDirection_IgnoreBool;
  esp_err_t indicateDirection_FinalReturn;
  CMOCK_MEM_INDEX_TYPE indicateDirection_CallInstance;
} Mock;


void Mockindicators_Verify(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_MEM_INDEX_TYPE call_instance;
  call_instance = Mock.indicateWifiConnected_CallInstance;
  if (Mock.indicateWifiConnected_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_indicateWifiConnected);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.indicateWifiNotConnected_CallInstance;
  if (Mock.indicateWifiNotConnected_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_indicateWifiNotConnected);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.indicateOTAAvailable_CallInstance;
  if (Mock.indicateOTAAvailable_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_indicateOTAAvailable);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.indicateOTAUpdate_CallInstance;
  if (Mock.indicateOTAUpdate_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_indicateOTAUpdate);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.indicateOTAFailure_CallInstance;
  if (Mock.indicateOTAFailure_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_indicateOTAFailure);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.indicateOTASuccess_CallInstance;
  if (Mock.indicateOTASuccess_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_indicateOTASuccess);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.indicateNorthbound_CallInstance;
  if (Mock.indicateNorthbound_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_indicateNorthbound);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.indicateSouthbound_CallInstance;
  if (Mock.indicateSouthbound_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_indicateSouthbound);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.indicateDirection_CallInstance;
  if (Mock.indicateDirection_IgnoreBool)
    call_instance = CMOCK_GUTS_NONE;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_indicateDirection);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
}

void Mockindicators_Init(void)
{
  Mockindicators_Destroy();
}

void Mockindicators_Destroy(void)
{
  CMock_Guts_MemFreeAll();
  memset(&Mock, 0, sizeof(Mock));
}

esp_err_t indicateWifiConnected(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_indicateWifiConnected_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_indicateWifiConnected);
  cmock_call_instance = (CMOCK_indicateWifiConnected_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.indicateWifiConnected_CallInstance);
  Mock.indicateWifiConnected_CallInstance = CMock_Guts_MemNext(Mock.indicateWifiConnected_CallInstance);
  if (Mock.indicateWifiConnected_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.indicateWifiConnected_FinalReturn;
    memcpy((void*)(&Mock.indicateWifiConnected_FinalReturn), (const void*)(&cmock_call_instance->ReturnVal),
         sizeof(esp_err_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(esp_err_t) ? 1 : -1])); /* add esp_err_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void indicateWifiConnected_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, esp_err_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_indicateWifiConnected_CALL_INSTANCE));
  CMOCK_indicateWifiConnected_CALL_INSTANCE* cmock_call_instance = (CMOCK_indicateWifiConnected_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.indicateWifiConnected_CallInstance = CMock_Guts_MemChain(Mock.indicateWifiConnected_CallInstance, cmock_guts_index);
  Mock.indicateWifiConnected_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.indicateWifiConnected_IgnoreBool = (char)1;
}

void indicateWifiConnected_CMockStopIgnore(void)
{
  if(Mock.indicateWifiConnected_IgnoreBool)
    Mock.indicateWifiConnected_CallInstance = CMock_Guts_MemNext(Mock.indicateWifiConnected_CallInstance);
  Mock.indicateWifiConnected_IgnoreBool = (char)0;
}

void indicateWifiConnected_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, esp_err_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_indicateWifiConnected_CALL_INSTANCE));
  CMOCK_indicateWifiConnected_CALL_INSTANCE* cmock_call_instance = (CMOCK_indicateWifiConnected_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.indicateWifiConnected_CallInstance = CMock_Guts_MemChain(Mock.indicateWifiConnected_CallInstance, cmock_guts_index);
  Mock.indicateWifiConnected_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  memcpy((void*)(&cmock_call_instance->ReturnVal), (const void*)(&cmock_to_return),
         sizeof(esp_err_t[sizeof(cmock_to_return) == sizeof(esp_err_t) ? 1 : -1])); /* add esp_err_t to :treat_as_array if this causes an error */
}

esp_err_t indicateWifiNotConnected(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_indicateWifiNotConnected_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_indicateWifiNotConnected);
  cmock_call_instance = (CMOCK_indicateWifiNotConnected_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.indicateWifiNotConnected_CallInstance);
  Mock.indicateWifiNotConnected_CallInstance = CMock_Guts_MemNext(Mock.indicateWifiNotConnected_CallInstance);
  if (Mock.indicateWifiNotConnected_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.indicateWifiNotConnected_FinalReturn;
    memcpy((void*)(&Mock.indicateWifiNotConnected_FinalReturn), (const void*)(&cmock_call_instance->ReturnVal),
         sizeof(esp_err_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(esp_err_t) ? 1 : -1])); /* add esp_err_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void indicateWifiNotConnected_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, esp_err_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_indicateWifiNotConnected_CALL_INSTANCE));
  CMOCK_indicateWifiNotConnected_CALL_INSTANCE* cmock_call_instance = (CMOCK_indicateWifiNotConnected_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.indicateWifiNotConnected_CallInstance = CMock_Guts_MemChain(Mock.indicateWifiNotConnected_CallInstance, cmock_guts_index);
  Mock.indicateWifiNotConnected_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.indicateWifiNotConnected_IgnoreBool = (char)1;
}

void indicateWifiNotConnected_CMockStopIgnore(void)
{
  if(Mock.indicateWifiNotConnected_IgnoreBool)
    Mock.indicateWifiNotConnected_CallInstance = CMock_Guts_MemNext(Mock.indicateWifiNotConnected_CallInstance);
  Mock.indicateWifiNotConnected_IgnoreBool = (char)0;
}

void indicateWifiNotConnected_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, esp_err_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_indicateWifiNotConnected_CALL_INSTANCE));
  CMOCK_indicateWifiNotConnected_CALL_INSTANCE* cmock_call_instance = (CMOCK_indicateWifiNotConnected_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.indicateWifiNotConnected_CallInstance = CMock_Guts_MemChain(Mock.indicateWifiNotConnected_CallInstance, cmock_guts_index);
  Mock.indicateWifiNotConnected_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  memcpy((void*)(&cmock_call_instance->ReturnVal), (const void*)(&cmock_to_return),
         sizeof(esp_err_t[sizeof(cmock_to_return) == sizeof(esp_err_t) ? 1 : -1])); /* add esp_err_t to :treat_as_array if this causes an error */
}

esp_err_t indicateOTAAvailable(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_indicateOTAAvailable_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_indicateOTAAvailable);
  cmock_call_instance = (CMOCK_indicateOTAAvailable_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.indicateOTAAvailable_CallInstance);
  Mock.indicateOTAAvailable_CallInstance = CMock_Guts_MemNext(Mock.indicateOTAAvailable_CallInstance);
  if (Mock.indicateOTAAvailable_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.indicateOTAAvailable_FinalReturn;
    memcpy((void*)(&Mock.indicateOTAAvailable_FinalReturn), (const void*)(&cmock_call_instance->ReturnVal),
         sizeof(esp_err_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(esp_err_t) ? 1 : -1])); /* add esp_err_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void indicateOTAAvailable_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, esp_err_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_indicateOTAAvailable_CALL_INSTANCE));
  CMOCK_indicateOTAAvailable_CALL_INSTANCE* cmock_call_instance = (CMOCK_indicateOTAAvailable_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.indicateOTAAvailable_CallInstance = CMock_Guts_MemChain(Mock.indicateOTAAvailable_CallInstance, cmock_guts_index);
  Mock.indicateOTAAvailable_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.indicateOTAAvailable_IgnoreBool = (char)1;
}

void indicateOTAAvailable_CMockStopIgnore(void)
{
  if(Mock.indicateOTAAvailable_IgnoreBool)
    Mock.indicateOTAAvailable_CallInstance = CMock_Guts_MemNext(Mock.indicateOTAAvailable_CallInstance);
  Mock.indicateOTAAvailable_IgnoreBool = (char)0;
}

void indicateOTAAvailable_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, esp_err_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_indicateOTAAvailable_CALL_INSTANCE));
  CMOCK_indicateOTAAvailable_CALL_INSTANCE* cmock_call_instance = (CMOCK_indicateOTAAvailable_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.indicateOTAAvailable_CallInstance = CMock_Guts_MemChain(Mock.indicateOTAAvailable_CallInstance, cmock_guts_index);
  Mock.indicateOTAAvailable_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  memcpy((void*)(&cmock_call_instance->ReturnVal), (const void*)(&cmock_to_return),
         sizeof(esp_err_t[sizeof(cmock_to_return) == sizeof(esp_err_t) ? 1 : -1])); /* add esp_err_t to :treat_as_array if this causes an error */
}

esp_err_t indicateOTAUpdate(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_indicateOTAUpdate_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_indicateOTAUpdate);
  cmock_call_instance = (CMOCK_indicateOTAUpdate_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.indicateOTAUpdate_CallInstance);
  Mock.indicateOTAUpdate_CallInstance = CMock_Guts_MemNext(Mock.indicateOTAUpdate_CallInstance);
  if (Mock.indicateOTAUpdate_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.indicateOTAUpdate_FinalReturn;
    memcpy((void*)(&Mock.indicateOTAUpdate_FinalReturn), (const void*)(&cmock_call_instance->ReturnVal),
         sizeof(esp_err_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(esp_err_t) ? 1 : -1])); /* add esp_err_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void indicateOTAUpdate_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, esp_err_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_indicateOTAUpdate_CALL_INSTANCE));
  CMOCK_indicateOTAUpdate_CALL_INSTANCE* cmock_call_instance = (CMOCK_indicateOTAUpdate_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.indicateOTAUpdate_CallInstance = CMock_Guts_MemChain(Mock.indicateOTAUpdate_CallInstance, cmock_guts_index);
  Mock.indicateOTAUpdate_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.indicateOTAUpdate_IgnoreBool = (char)1;
}

void indicateOTAUpdate_CMockStopIgnore(void)
{
  if(Mock.indicateOTAUpdate_IgnoreBool)
    Mock.indicateOTAUpdate_CallInstance = CMock_Guts_MemNext(Mock.indicateOTAUpdate_CallInstance);
  Mock.indicateOTAUpdate_IgnoreBool = (char)0;
}

void indicateOTAUpdate_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, esp_err_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_indicateOTAUpdate_CALL_INSTANCE));
  CMOCK_indicateOTAUpdate_CALL_INSTANCE* cmock_call_instance = (CMOCK_indicateOTAUpdate_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.indicateOTAUpdate_CallInstance = CMock_Guts_MemChain(Mock.indicateOTAUpdate_CallInstance, cmock_guts_index);
  Mock.indicateOTAUpdate_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  memcpy((void*)(&cmock_call_instance->ReturnVal), (const void*)(&cmock_to_return),
         sizeof(esp_err_t[sizeof(cmock_to_return) == sizeof(esp_err_t) ? 1 : -1])); /* add esp_err_t to :treat_as_array if this causes an error */
}

esp_err_t indicateOTAFailure(int32_t delay)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_indicateOTAFailure_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_indicateOTAFailure);
  cmock_call_instance = (CMOCK_indicateOTAFailure_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.indicateOTAFailure_CallInstance);
  Mock.indicateOTAFailure_CallInstance = CMock_Guts_MemNext(Mock.indicateOTAFailure_CallInstance);
  if (Mock.indicateOTAFailure_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.indicateOTAFailure_FinalReturn;
    memcpy((void*)(&Mock.indicateOTAFailure_FinalReturn), (const void*)(&cmock_call_instance->ReturnVal),
         sizeof(esp_err_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(esp_err_t) ? 1 : -1])); /* add esp_err_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_indicateOTAFailure,CMockString_delay);
    UNITY_TEST_ASSERT_EQUAL_INT(cmock_call_instance->Expected_delay, delay, cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_indicateOTAFailure(CMOCK_indicateOTAFailure_CALL_INSTANCE* cmock_call_instance, int32_t delay);
void CMockExpectParameters_indicateOTAFailure(CMOCK_indicateOTAFailure_CALL_INSTANCE* cmock_call_instance, int32_t delay)
{
  cmock_call_instance->Expected_delay = delay;
}

void indicateOTAFailure_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, esp_err_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_indicateOTAFailure_CALL_INSTANCE));
  CMOCK_indicateOTAFailure_CALL_INSTANCE* cmock_call_instance = (CMOCK_indicateOTAFailure_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.indicateOTAFailure_CallInstance = CMock_Guts_MemChain(Mock.indicateOTAFailure_CallInstance, cmock_guts_index);
  Mock.indicateOTAFailure_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.indicateOTAFailure_IgnoreBool = (char)1;
}

void indicateOTAFailure_CMockStopIgnore(void)
{
  if(Mock.indicateOTAFailure_IgnoreBool)
    Mock.indicateOTAFailure_CallInstance = CMock_Guts_MemNext(Mock.indicateOTAFailure_CallInstance);
  Mock.indicateOTAFailure_IgnoreBool = (char)0;
}

void indicateOTAFailure_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, int32_t delay, esp_err_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_indicateOTAFailure_CALL_INSTANCE));
  CMOCK_indicateOTAFailure_CALL_INSTANCE* cmock_call_instance = (CMOCK_indicateOTAFailure_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.indicateOTAFailure_CallInstance = CMock_Guts_MemChain(Mock.indicateOTAFailure_CallInstance, cmock_guts_index);
  Mock.indicateOTAFailure_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_indicateOTAFailure(cmock_call_instance, delay);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (const void*)(&cmock_to_return),
         sizeof(esp_err_t[sizeof(cmock_to_return) == sizeof(esp_err_t) ? 1 : -1])); /* add esp_err_t to :treat_as_array if this causes an error */
}

esp_err_t indicateOTASuccess(int32_t delay)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_indicateOTASuccess_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_indicateOTASuccess);
  cmock_call_instance = (CMOCK_indicateOTASuccess_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.indicateOTASuccess_CallInstance);
  Mock.indicateOTASuccess_CallInstance = CMock_Guts_MemNext(Mock.indicateOTASuccess_CallInstance);
  if (Mock.indicateOTASuccess_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.indicateOTASuccess_FinalReturn;
    memcpy((void*)(&Mock.indicateOTASuccess_FinalReturn), (const void*)(&cmock_call_instance->ReturnVal),
         sizeof(esp_err_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(esp_err_t) ? 1 : -1])); /* add esp_err_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_indicateOTASuccess,CMockString_delay);
    UNITY_TEST_ASSERT_EQUAL_INT(cmock_call_instance->Expected_delay, delay, cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_indicateOTASuccess(CMOCK_indicateOTASuccess_CALL_INSTANCE* cmock_call_instance, int32_t delay);
void CMockExpectParameters_indicateOTASuccess(CMOCK_indicateOTASuccess_CALL_INSTANCE* cmock_call_instance, int32_t delay)
{
  cmock_call_instance->Expected_delay = delay;
}

void indicateOTASuccess_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, esp_err_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_indicateOTASuccess_CALL_INSTANCE));
  CMOCK_indicateOTASuccess_CALL_INSTANCE* cmock_call_instance = (CMOCK_indicateOTASuccess_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.indicateOTASuccess_CallInstance = CMock_Guts_MemChain(Mock.indicateOTASuccess_CallInstance, cmock_guts_index);
  Mock.indicateOTASuccess_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.indicateOTASuccess_IgnoreBool = (char)1;
}

void indicateOTASuccess_CMockStopIgnore(void)
{
  if(Mock.indicateOTASuccess_IgnoreBool)
    Mock.indicateOTASuccess_CallInstance = CMock_Guts_MemNext(Mock.indicateOTASuccess_CallInstance);
  Mock.indicateOTASuccess_IgnoreBool = (char)0;
}

void indicateOTASuccess_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, int32_t delay, esp_err_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_indicateOTASuccess_CALL_INSTANCE));
  CMOCK_indicateOTASuccess_CALL_INSTANCE* cmock_call_instance = (CMOCK_indicateOTASuccess_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.indicateOTASuccess_CallInstance = CMock_Guts_MemChain(Mock.indicateOTASuccess_CallInstance, cmock_guts_index);
  Mock.indicateOTASuccess_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_indicateOTASuccess(cmock_call_instance, delay);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (const void*)(&cmock_to_return),
         sizeof(esp_err_t[sizeof(cmock_to_return) == sizeof(esp_err_t) ? 1 : -1])); /* add esp_err_t to :treat_as_array if this causes an error */
}

esp_err_t indicateNorthbound(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_indicateNorthbound_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_indicateNorthbound);
  cmock_call_instance = (CMOCK_indicateNorthbound_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.indicateNorthbound_CallInstance);
  Mock.indicateNorthbound_CallInstance = CMock_Guts_MemNext(Mock.indicateNorthbound_CallInstance);
  if (Mock.indicateNorthbound_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.indicateNorthbound_FinalReturn;
    memcpy((void*)(&Mock.indicateNorthbound_FinalReturn), (const void*)(&cmock_call_instance->ReturnVal),
         sizeof(esp_err_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(esp_err_t) ? 1 : -1])); /* add esp_err_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void indicateNorthbound_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, esp_err_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_indicateNorthbound_CALL_INSTANCE));
  CMOCK_indicateNorthbound_CALL_INSTANCE* cmock_call_instance = (CMOCK_indicateNorthbound_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.indicateNorthbound_CallInstance = CMock_Guts_MemChain(Mock.indicateNorthbound_CallInstance, cmock_guts_index);
  Mock.indicateNorthbound_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.indicateNorthbound_IgnoreBool = (char)1;
}

void indicateNorthbound_CMockStopIgnore(void)
{
  if(Mock.indicateNorthbound_IgnoreBool)
    Mock.indicateNorthbound_CallInstance = CMock_Guts_MemNext(Mock.indicateNorthbound_CallInstance);
  Mock.indicateNorthbound_IgnoreBool = (char)0;
}

void indicateNorthbound_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, esp_err_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_indicateNorthbound_CALL_INSTANCE));
  CMOCK_indicateNorthbound_CALL_INSTANCE* cmock_call_instance = (CMOCK_indicateNorthbound_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.indicateNorthbound_CallInstance = CMock_Guts_MemChain(Mock.indicateNorthbound_CallInstance, cmock_guts_index);
  Mock.indicateNorthbound_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  memcpy((void*)(&cmock_call_instance->ReturnVal), (const void*)(&cmock_to_return),
         sizeof(esp_err_t[sizeof(cmock_to_return) == sizeof(esp_err_t) ? 1 : -1])); /* add esp_err_t to :treat_as_array if this causes an error */
}

esp_err_t indicateSouthbound(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_indicateSouthbound_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_indicateSouthbound);
  cmock_call_instance = (CMOCK_indicateSouthbound_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.indicateSouthbound_CallInstance);
  Mock.indicateSouthbound_CallInstance = CMock_Guts_MemNext(Mock.indicateSouthbound_CallInstance);
  if (Mock.indicateSouthbound_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.indicateSouthbound_FinalReturn;
    memcpy((void*)(&Mock.indicateSouthbound_FinalReturn), (const void*)(&cmock_call_instance->ReturnVal),
         sizeof(esp_err_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(esp_err_t) ? 1 : -1])); /* add esp_err_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void indicateSouthbound_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, esp_err_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_indicateSouthbound_CALL_INSTANCE));
  CMOCK_indicateSouthbound_CALL_INSTANCE* cmock_call_instance = (CMOCK_indicateSouthbound_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.indicateSouthbound_CallInstance = CMock_Guts_MemChain(Mock.indicateSouthbound_CallInstance, cmock_guts_index);
  Mock.indicateSouthbound_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.indicateSouthbound_IgnoreBool = (char)1;
}

void indicateSouthbound_CMockStopIgnore(void)
{
  if(Mock.indicateSouthbound_IgnoreBool)
    Mock.indicateSouthbound_CallInstance = CMock_Guts_MemNext(Mock.indicateSouthbound_CallInstance);
  Mock.indicateSouthbound_IgnoreBool = (char)0;
}

void indicateSouthbound_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, esp_err_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_indicateSouthbound_CALL_INSTANCE));
  CMOCK_indicateSouthbound_CALL_INSTANCE* cmock_call_instance = (CMOCK_indicateSouthbound_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.indicateSouthbound_CallInstance = CMock_Guts_MemChain(Mock.indicateSouthbound_CallInstance, cmock_guts_index);
  Mock.indicateSouthbound_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  memcpy((void*)(&cmock_call_instance->ReturnVal), (const void*)(&cmock_to_return),
         sizeof(esp_err_t[sizeof(cmock_to_return) == sizeof(esp_err_t) ? 1 : -1])); /* add esp_err_t to :treat_as_array if this causes an error */
}

esp_err_t indicateDirection(Direction dir)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_indicateDirection_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_indicateDirection);
  cmock_call_instance = (CMOCK_indicateDirection_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.indicateDirection_CallInstance);
  Mock.indicateDirection_CallInstance = CMock_Guts_MemNext(Mock.indicateDirection_CallInstance);
  if (Mock.indicateDirection_IgnoreBool)
  {
    UNITY_CLR_DETAILS();
    if (cmock_call_instance == NULL)
      return Mock.indicateDirection_FinalReturn;
    memcpy((void*)(&Mock.indicateDirection_FinalReturn), (const void*)(&cmock_call_instance->ReturnVal),
         sizeof(esp_err_t[sizeof(cmock_call_instance->ReturnVal) == sizeof(esp_err_t) ? 1 : -1])); /* add esp_err_t to :treat_as_array if this causes an error */
    return cmock_call_instance->ReturnVal;
  }
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_indicateDirection,CMockString_dir);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_dir), (void*)(&dir), sizeof(Direction), cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_indicateDirection(CMOCK_indicateDirection_CALL_INSTANCE* cmock_call_instance, Direction dir);
void CMockExpectParameters_indicateDirection(CMOCK_indicateDirection_CALL_INSTANCE* cmock_call_instance, Direction dir)
{
  memcpy((void*)(&cmock_call_instance->Expected_dir), (const void*)(&dir),
         sizeof(Direction[sizeof(dir) == sizeof(Direction) ? 1 : -1])); /* add Direction to :treat_as_array if this causes an error */
}

void indicateDirection_CMockIgnoreAndReturn(UNITY_LINE_TYPE cmock_line, esp_err_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_indicateDirection_CALL_INSTANCE));
  CMOCK_indicateDirection_CALL_INSTANCE* cmock_call_instance = (CMOCK_indicateDirection_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.indicateDirection_CallInstance = CMock_Guts_MemChain(Mock.indicateDirection_CallInstance, cmock_guts_index);
  Mock.indicateDirection_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
  Mock.indicateDirection_IgnoreBool = (char)1;
}

void indicateDirection_CMockStopIgnore(void)
{
  if(Mock.indicateDirection_IgnoreBool)
    Mock.indicateDirection_CallInstance = CMock_Guts_MemNext(Mock.indicateDirection_CallInstance);
  Mock.indicateDirection_IgnoreBool = (char)0;
}

void indicateDirection_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, Direction dir, esp_err_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_indicateDirection_CALL_INSTANCE));
  CMOCK_indicateDirection_CALL_INSTANCE* cmock_call_instance = (CMOCK_indicateDirection_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.indicateDirection_CallInstance = CMock_Guts_MemChain(Mock.indicateDirection_CallInstance, cmock_guts_index);
  Mock.indicateDirection_IgnoreBool = (char)0;
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_indicateDirection(cmock_call_instance, dir);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (const void*)(&cmock_to_return),
         sizeof(esp_err_t[sizeof(cmock_to_return) == sizeof(esp_err_t) ? 1 : -1])); /* add esp_err_t to :treat_as_array if this causes an error */
}

