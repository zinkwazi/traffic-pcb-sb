/**
 * api_connect.c
 * 
 * Contains functions for connecting to and retrieving data from the server.
 */

// #include "api_connect.h"
#include "api_connect.h"

#include "circular_buffer.h"

#include "esp_log.h"
#include "esp_http_client.h"
#include "esp_err.h"
#include "esp_assert.h"

#include <stdbool.h>
#include <stdint.h>

/* The size in chars of the block size api http responses will be received in,
   which will be added to a circular buffer of double the size. This allows
   blocks that do not exactly align with blocks to be handled.  */
#define RESPONSE_BLOCK_SIZE (128)
#define CIRC_BUF_SIZE (2 * RESPONSE_BLOCK_SIZE)

#define TAG "api_connect"

/**
 * @brief Parses the next CSV entry from the mark in circBuf and remark the next
 *        newline character in the buffer. 
 * 
 * @note If the mark is on a '\n' in the circBuf, the character will be skipped.
 *       This prevents the caller from needing to remember to move the mark
 *       generated by this function, which marks the first found '\n'.
 * 
 * @param[out] data The location to which retrieved data will be stored.
 * @param[in] circBuf The circular buffer to parse the next entry from.
 * @param[in] buf An array of length bufSize, used internally by the function.
 *        Assume that the data inside buf is scrambled after use.
 * 
 * @returns ESP_OK if successful. 
 *          ESP_ERR_NOT_FOUND if no data was found.
 *          API_ERR_REMOVE_DATA if speed is -1, indicating that the datapoint
 *          should be removed if it currently exists. It is probably the case
 *          that the LED number returned corresponds to a special LED in this
 *          version of the hardware.
 *          ESP_FAIL otherwise and the circular buffer mark is unmodified, 
 *          however buf is potentially modified.
 */
esp_err_t nextCSVEntryFromMark(LEDData *data, CircularBuffer *circBuf, char *buf, uint32_t bufSize) {
    circ_err_t circ_err;
    int bufferLen = 0;
    int bytesRead = 0;
    int commaNdx = 0;
    int64_t entryLEDNum = -INT64_MAX;
    int64_t entrySpeed = -INT64_MAX;
    /* input guards */
    if (data == NULL || 
        circBuf == NULL || 
        buf == NULL || 
        bufSize == 0) 
    {
        return ESP_FAIL;
    }
    /* retrieve data from circular buffer */
    bufferLen = circularBufferReadFromMark(circBuf, buf, bufSize - 1);
    if (bufferLen < 0) {
        return ESP_FAIL;
    }
    /* parse CSV data from linear buffer */
    int i = 0;
    if (buf[i] == '\n') {
        i++; // the user of the func will prob forget to move the mark manually.
    }
    for (; i < bufferLen; i++) {
        if (buf[i] == '\0') {
            return ESP_FAIL; // did not finish the entry
        }
        if (buf[i] == ',' && entryLEDNum == -INT64_MAX) {
            commaNdx = i;
            entryLEDNum = strtol(&buf[0], NULL, 10);
            if (errno != 0) {
                ESP_LOGI(TAG, "strtol failure parsing CSV");
                return ESP_FAIL;
            }
        } else if (buf[i] == ',' && entryLEDNum != -INT64_MAX) {
            return ESP_FAIL;
        }
        if (buf[i] == '\n') {
            bytesRead = i; // don't include this newline character
            entrySpeed = strtol(&buf[commaNdx + 1], NULL, 10);
            if (errno != 0) {
                ESP_LOGI(TAG, "strtol failure parsing CSV");
                return ESP_FAIL;
            }
            break;
        }
    }
    if (entryLEDNum == -INT64_MAX || entrySpeed == -INT64_MAX) {
        return ESP_ERR_NOT_FOUND;
    }
    /* remark circular buffer */
    circ_err = circularBufferMark(circBuf, bytesRead, FROM_PREV_MARK);
    if (circ_err != CIRC_OK) {
        return ESP_FAIL;
    }
    /* return data */
    data->ledNum = (uint32_t) entryLEDNum;
    data->speed = (uint32_t) entrySpeed;
    if (entrySpeed == -1) {
        return API_ERR_REMOVE_DATA;
    }
    return ESP_OK;
}

/**
 * requires client to have data to read
 */
esp_err_t readServerSpeedData(LEDData ledSpeeds[], uint32_t ledSpeedsLen, esp_http_client_handle_t client) {
    CircularBuffer circBuf;
    circ_err_t circ_err;
    esp_err_t err;
    char circBufBacking[CIRC_BUF_SIZE];
    char buffer[RESPONSE_BLOCK_SIZE];
    int64_t bytesRead;
    LEDData result;
    /* input guards */
    if (ledSpeeds == NULL ||
        ledSpeedsLen == 0 ||
        client == NULL)
    {
        ESP_LOGE(TAG, "invalid arg");
        return ESP_ERR_INVALID_ARG;
    }
    /* initialize circular buffer */
    circ_err = circularBufferInit(&circBuf, circBufBacking, CIRC_BUF_SIZE);
    if (circ_err != CIRC_OK) {
        ESP_LOGE(TAG, "failed to initialize circular buffer");
        return ESP_FAIL;
    }
    /* load initial data and mark beginning */
    do {
        bytesRead = esp_http_client_read(client, buffer, RESPONSE_BLOCK_SIZE - 1);
        if (bytesRead == -1) {
            ESP_LOGE(TAG, "esp_http_client_read returned -1");
            return ESP_FAIL;
        }
    } while (bytesRead == -ESP_ERR_HTTP_EAGAIN);
    circ_err = circularBufferStore(&circBuf, buffer, bytesRead);
    if (circ_err != CIRC_OK) {
        ESP_LOGE(TAG, "failed to write data to circ buffer. got err: %d", circ_err);
        return ESP_FAIL;
    }
    circ_err = circularBufferMark(&circBuf, 0, FROM_OLDEST_CHAR);
    if (circ_err != CIRC_OK) {
        ESP_LOGE(TAG, "failed to mark circular buffer");
        return ESP_FAIL;
    }
    while (bytesRead > 0) {
        /* parse rows while available */
        do {
            err = nextCSVEntryFromMark(&result, &circBuf, buffer, RESPONSE_BLOCK_SIZE);
            if (err == ESP_FAIL) {
                ESP_LOGE(TAG, "nextCSVEntryFromMark failed");
                return ESP_FAIL;
            }
            switch (err) {
                case ESP_OK:
                    /* set data point */
                    ledSpeeds[result.ledNum - 1].ledNum = result.ledNum;
                    ledSpeeds[result.ledNum - 1].speed = result.speed;
                    break;
                case API_ERR_REMOVE_DATA:
                    /* remove data point */
                    ledSpeeds[result.ledNum - 1].ledNum = 0;
                    ledSpeeds[result.ledNum - 1].speed = 0;
                    break;
                default:
                    break;
            }
        } while (err != ESP_ERR_NOT_FOUND);
        /* read new data from response */
        do {
            bytesRead = esp_http_client_read(client, buffer, RESPONSE_BLOCK_SIZE - 1);
            if (bytesRead == -1) {
                ESP_LOGE(TAG, "esp_http_client_read returned -1");
                return ESP_FAIL;
            }
        } while (bytesRead == -ESP_ERR_HTTP_EAGAIN);
        if (bytesRead == 0) {
            break;
        }
        circ_err = circularBufferStore(&circBuf, buffer, (uint32_t) bytesRead);
        if (circ_err != CIRC_OK) {
            ESP_LOGE(TAG, "failed to write data to circ buffer, err: %d", circ_err);
            return ESP_FAIL;
        }
    }
    ESP_LOGW(TAG, "returned normally");
    return ESP_OK;
}

/**
 * Retrieves the current speeds from the server.
 * 
 * Parameters:
 *     speeds: Where the current speed data will be stored
 */
esp_err_t getServerSpeeds(LEDData ledSpeeds[], uint32_t ledSpeedsLen, esp_http_client_handle_t client, char *URL, int retryNum) {
    esp_err_t err;
    /* input guards */
    ESP_STATIC_ASSERT(CIRC_BUF_SIZE >= (2 * RESPONSE_BLOCK_SIZE));
    if (ledSpeeds == NULL ||
        ledSpeedsLen == 0 ||
        client == NULL ||
        URL == NULL ||
        retryNum == 0)
    {
        return ESP_FAIL;
    }
    /* open connection and retrieve headers */
    ESP_LOGI(TAG, "retrieving: %s", URL);
    if (esp_http_client_set_url(client, URL) != ESP_OK) {
        return ESP_FAIL;
    }
    if (esp_http_client_open(client, 0) != ESP_OK) {
        ESP_LOGE(TAG, "failed to open connection");
        return ESP_FAIL;
    }
    int64_t contentLength = esp_http_client_fetch_headers(client);
    while (contentLength == -ESP_ERR_HTTP_EAGAIN) {
        contentLength = esp_http_client_fetch_headers(client);
    }
    if (contentLength <= 0) {
        ESP_LOGW(TAG, "contentLength <= 0");
        if (esp_http_client_close(client) != ESP_OK) {
            ESP_LOGE(TAG, "failed to close client");
        }
        return ESP_FAIL;
    }
    int status = esp_http_client_get_status_code(client);
    if (esp_http_client_get_status_code(client) != 200) {
        ESP_LOGE(TAG, "status code is %d", status);
        if (esp_http_client_close(client) != ESP_OK) {
            ESP_LOGE(TAG, "failed to close client");
        }
        return ESP_FAIL;
    }
    err = readServerSpeedData(ledSpeeds, ledSpeedsLen, client);
    if (err != ESP_OK) {
        if (esp_http_client_close(client) != ESP_OK) {
            ESP_LOGE(TAG, "failed to close client");
        }
        ESP_LOGE(TAG, "failed to read speed data");
        ESP_LOGW(TAG, "err: %d", err);
        return err;
    }
    if (esp_http_client_close(client) != ESP_OK) {
        ESP_LOGE(TAG, "failed to close client");
        return ESP_FAIL;
    }

    for (int i = 0; i < ledSpeedsLen; i++) {
        ESP_LOGI(TAG, "ndx: %d, num: %lu, speed: %lu", i, ledSpeeds[i].ledNum, ledSpeeds[i].speed);
    }
    return ESP_OK;
}

#ifndef DISABLE_TESTING_FEATURES

int getResponseBlockSize(void) {
    return RESPONSE_BLOCK_SIZE;
}

int getCircBufSize(void) {
    return CIRC_BUF_SIZE;
}

#endif /* DISABLE_TESTING_FEATURES */