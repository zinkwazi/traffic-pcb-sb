/* AUTOGENERATED FILE. DO NOT EDIT. */
#include <string.h>
#include <stdlib.h>
#include <setjmp.h>
#include "cmock.h"
#include "Mockrefresh.h"

static const char* CMockString_anim = "anim";
static const char* CMockString_category = "category";
static const char* CMockString_clearBoard = "clearBoard";
static const char* CMockString_client = "client";
static const char* CMockString_data = "data";
static const char* CMockString_dir = "dir";
static const char* CMockString_initHttpClient = "initHttpClient";
static const char* CMockString_initRefresh = "initRefresh";
static const char* CMockString_quick = "quick";
static const char* CMockString_quickClearBoard = "quickClearBoard";
static const char* CMockString_refreshBoard = "refreshBoard";
static const char* CMockString_refreshData = "refreshData";

typedef struct _CMOCK_initRefresh_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  esp_err_t ReturnVal;

} CMOCK_initRefresh_CALL_INSTANCE;

typedef struct _CMOCK_initHttpClient_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  esp_http_client_handle_t ReturnVal;

} CMOCK_initHttpClient_CALL_INSTANCE;

typedef struct _CMOCK_clearBoard_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  esp_err_t ReturnVal;
  Direction Expected_dir;
  bool Expected_quick;

} CMOCK_clearBoard_CALL_INSTANCE;

typedef struct _CMOCK_quickClearBoard_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  esp_err_t ReturnVal;
  Direction Expected_dir;

} CMOCK_quickClearBoard_CALL_INSTANCE;

typedef struct _CMOCK_refreshData_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  esp_err_t ReturnVal;
  LEDData* Expected_data;
  esp_http_client_handle_t Expected_client;
  Direction Expected_dir;
  SpeedCategory Expected_category;

} CMOCK_refreshData_CALL_INSTANCE;

typedef struct _CMOCK_refreshBoard_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  esp_err_t ReturnVal;
  Direction Expected_dir;
  Animation Expected_anim;

} CMOCK_refreshBoard_CALL_INSTANCE;

static struct MockrefreshInstance
{
  CMOCK_MEM_INDEX_TYPE initRefresh_CallInstance;
  CMOCK_MEM_INDEX_TYPE initHttpClient_CallInstance;
  CMOCK_MEM_INDEX_TYPE clearBoard_CallInstance;
  CMOCK_MEM_INDEX_TYPE quickClearBoard_CallInstance;
  CMOCK_MEM_INDEX_TYPE refreshData_CallInstance;
  CMOCK_MEM_INDEX_TYPE refreshBoard_CallInstance;
} Mock;


void Mockrefresh_Verify(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_MEM_INDEX_TYPE call_instance;
  call_instance = Mock.initRefresh_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_initRefresh);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.initHttpClient_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_initHttpClient);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.clearBoard_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_clearBoard);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.quickClearBoard_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_quickClearBoard);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.refreshData_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_refreshData);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.refreshBoard_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_refreshBoard);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
}

void Mockrefresh_Init(void)
{
  Mockrefresh_Destroy();
}

void Mockrefresh_Destroy(void)
{
  CMock_Guts_MemFreeAll();
  memset(&Mock, 0, sizeof(Mock));
}

esp_err_t initRefresh(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_initRefresh_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_initRefresh);
  cmock_call_instance = (CMOCK_initRefresh_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.initRefresh_CallInstance);
  Mock.initRefresh_CallInstance = CMock_Guts_MemNext(Mock.initRefresh_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void initRefresh_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, esp_err_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_initRefresh_CALL_INSTANCE));
  CMOCK_initRefresh_CALL_INSTANCE* cmock_call_instance = (CMOCK_initRefresh_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.initRefresh_CallInstance = CMock_Guts_MemChain(Mock.initRefresh_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  memcpy((void*)(&cmock_call_instance->ReturnVal), (const void*)(&cmock_to_return),
         sizeof(esp_err_t[sizeof(cmock_to_return) == sizeof(esp_err_t) ? 1 : -1])); /* add esp_err_t to :treat_as_array if this causes an error */
}

esp_http_client_handle_t initHttpClient(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_initHttpClient_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_initHttpClient);
  cmock_call_instance = (CMOCK_initHttpClient_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.initHttpClient_CallInstance);
  Mock.initHttpClient_CallInstance = CMock_Guts_MemNext(Mock.initHttpClient_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void initHttpClient_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, esp_http_client_handle_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_initHttpClient_CALL_INSTANCE));
  CMOCK_initHttpClient_CALL_INSTANCE* cmock_call_instance = (CMOCK_initHttpClient_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.initHttpClient_CallInstance = CMock_Guts_MemChain(Mock.initHttpClient_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  memcpy((void*)(&cmock_call_instance->ReturnVal), (const void*)(&cmock_to_return),
         sizeof(esp_http_client_handle_t[sizeof(cmock_to_return) == sizeof(esp_http_client_handle_t) ? 1 : -1])); /* add esp_http_client_handle_t to :treat_as_array if this causes an error */
}

esp_err_t clearBoard(Direction dir, bool quick)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_clearBoard_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_clearBoard);
  cmock_call_instance = (CMOCK_clearBoard_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.clearBoard_CallInstance);
  Mock.clearBoard_CallInstance = CMock_Guts_MemNext(Mock.clearBoard_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_clearBoard,CMockString_dir);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_dir), (void*)(&dir), sizeof(Direction), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_clearBoard,CMockString_quick);
    UNITY_TEST_ASSERT_EQUAL_INT(cmock_call_instance->Expected_quick, quick, cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_clearBoard(CMOCK_clearBoard_CALL_INSTANCE* cmock_call_instance, Direction dir, bool quick);
void CMockExpectParameters_clearBoard(CMOCK_clearBoard_CALL_INSTANCE* cmock_call_instance, Direction dir, bool quick)
{
  memcpy((void*)(&cmock_call_instance->Expected_dir), (const void*)(&dir),
         sizeof(Direction[sizeof(dir) == sizeof(Direction) ? 1 : -1])); /* add Direction to :treat_as_array if this causes an error */
  cmock_call_instance->Expected_quick = quick;
}

void clearBoard_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, Direction dir, bool quick, esp_err_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_clearBoard_CALL_INSTANCE));
  CMOCK_clearBoard_CALL_INSTANCE* cmock_call_instance = (CMOCK_clearBoard_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.clearBoard_CallInstance = CMock_Guts_MemChain(Mock.clearBoard_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_clearBoard(cmock_call_instance, dir, quick);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (const void*)(&cmock_to_return),
         sizeof(esp_err_t[sizeof(cmock_to_return) == sizeof(esp_err_t) ? 1 : -1])); /* add esp_err_t to :treat_as_array if this causes an error */
}

esp_err_t quickClearBoard(Direction dir)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_quickClearBoard_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_quickClearBoard);
  cmock_call_instance = (CMOCK_quickClearBoard_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.quickClearBoard_CallInstance);
  Mock.quickClearBoard_CallInstance = CMock_Guts_MemNext(Mock.quickClearBoard_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_quickClearBoard,CMockString_dir);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_dir), (void*)(&dir), sizeof(Direction), cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_quickClearBoard(CMOCK_quickClearBoard_CALL_INSTANCE* cmock_call_instance, Direction dir);
void CMockExpectParameters_quickClearBoard(CMOCK_quickClearBoard_CALL_INSTANCE* cmock_call_instance, Direction dir)
{
  memcpy((void*)(&cmock_call_instance->Expected_dir), (const void*)(&dir),
         sizeof(Direction[sizeof(dir) == sizeof(Direction) ? 1 : -1])); /* add Direction to :treat_as_array if this causes an error */
}

void quickClearBoard_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, Direction dir, esp_err_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_quickClearBoard_CALL_INSTANCE));
  CMOCK_quickClearBoard_CALL_INSTANCE* cmock_call_instance = (CMOCK_quickClearBoard_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.quickClearBoard_CallInstance = CMock_Guts_MemChain(Mock.quickClearBoard_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_quickClearBoard(cmock_call_instance, dir);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (const void*)(&cmock_to_return),
         sizeof(esp_err_t[sizeof(cmock_to_return) == sizeof(esp_err_t) ? 1 : -1])); /* add esp_err_t to :treat_as_array if this causes an error */
}

esp_err_t refreshData(LEDData* data, esp_http_client_handle_t client, Direction dir, SpeedCategory category)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_refreshData_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_refreshData);
  cmock_call_instance = (CMOCK_refreshData_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.refreshData_CallInstance);
  Mock.refreshData_CallInstance = CMock_Guts_MemNext(Mock.refreshData_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_refreshData,CMockString_data);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_data), (void*)(data), sizeof(LEDData), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_refreshData,CMockString_client);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_client), (void*)(&client), sizeof(esp_http_client_handle_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_refreshData,CMockString_dir);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_dir), (void*)(&dir), sizeof(Direction), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_refreshData,CMockString_category);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_category), (void*)(&category), sizeof(SpeedCategory), cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_refreshData(CMOCK_refreshData_CALL_INSTANCE* cmock_call_instance, LEDData* data, esp_http_client_handle_t client, Direction dir, SpeedCategory category);
void CMockExpectParameters_refreshData(CMOCK_refreshData_CALL_INSTANCE* cmock_call_instance, LEDData* data, esp_http_client_handle_t client, Direction dir, SpeedCategory category)
{
  cmock_call_instance->Expected_data = data;
  memcpy((void*)(&cmock_call_instance->Expected_client), (const void*)(&client),
         sizeof(esp_http_client_handle_t[sizeof(client) == sizeof(esp_http_client_handle_t) ? 1 : -1])); /* add esp_http_client_handle_t to :treat_as_array if this causes an error */
  memcpy((void*)(&cmock_call_instance->Expected_dir), (const void*)(&dir),
         sizeof(Direction[sizeof(dir) == sizeof(Direction) ? 1 : -1])); /* add Direction to :treat_as_array if this causes an error */
  memcpy((void*)(&cmock_call_instance->Expected_category), (const void*)(&category),
         sizeof(SpeedCategory[sizeof(category) == sizeof(SpeedCategory) ? 1 : -1])); /* add SpeedCategory to :treat_as_array if this causes an error */
}

void refreshData_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, LEDData* data, esp_http_client_handle_t client, Direction dir, SpeedCategory category, esp_err_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_refreshData_CALL_INSTANCE));
  CMOCK_refreshData_CALL_INSTANCE* cmock_call_instance = (CMOCK_refreshData_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.refreshData_CallInstance = CMock_Guts_MemChain(Mock.refreshData_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_refreshData(cmock_call_instance, data, client, dir, category);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (const void*)(&cmock_to_return),
         sizeof(esp_err_t[sizeof(cmock_to_return) == sizeof(esp_err_t) ? 1 : -1])); /* add esp_err_t to :treat_as_array if this causes an error */
}

esp_err_t refreshBoard(Direction dir, Animation anim)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_refreshBoard_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_refreshBoard);
  cmock_call_instance = (CMOCK_refreshBoard_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.refreshBoard_CallInstance);
  Mock.refreshBoard_CallInstance = CMock_Guts_MemNext(Mock.refreshBoard_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_refreshBoard,CMockString_dir);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_dir), (void*)(&dir), sizeof(Direction), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_refreshBoard,CMockString_anim);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_anim), (void*)(&anim), sizeof(Animation), cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_refreshBoard(CMOCK_refreshBoard_CALL_INSTANCE* cmock_call_instance, Direction dir, Animation anim);
void CMockExpectParameters_refreshBoard(CMOCK_refreshBoard_CALL_INSTANCE* cmock_call_instance, Direction dir, Animation anim)
{
  memcpy((void*)(&cmock_call_instance->Expected_dir), (const void*)(&dir),
         sizeof(Direction[sizeof(dir) == sizeof(Direction) ? 1 : -1])); /* add Direction to :treat_as_array if this causes an error */
  memcpy((void*)(&cmock_call_instance->Expected_anim), (const void*)(&anim),
         sizeof(Animation[sizeof(anim) == sizeof(Animation) ? 1 : -1])); /* add Animation to :treat_as_array if this causes an error */
}

void refreshBoard_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, Direction dir, Animation anim, esp_err_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_refreshBoard_CALL_INSTANCE));
  CMOCK_refreshBoard_CALL_INSTANCE* cmock_call_instance = (CMOCK_refreshBoard_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.refreshBoard_CallInstance = CMock_Guts_MemChain(Mock.refreshBoard_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_refreshBoard(cmock_call_instance, dir, anim);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (const void*)(&cmock_to_return),
         sizeof(esp_err_t[sizeof(cmock_to_return) == sizeof(esp_err_t) ? 1 : -1])); /* add esp_err_t to :treat_as_array if this causes an error */
}

